package ast

import (
	"bytes"

	"github.com/ollybritton/calclang/token"
)

// Node is a node in the abstract syntax tree (AST) generated by the parser.
type Node interface {
	String() string     // String converts the node into its string representation.
	Token() token.Token // Token returns the token.Token associated with the node.
}

// Statement represents a statement in the AST. Statements are pieces of code that DO
// NOT produce a value.
// For example, "a <- 10" is a statement, whereas "a+10" is an expression.
type Statement interface {
	Node
	statementNode()
}

// Expression represents an expression in the AST. Expressions are pieces of code that
// DO produce a value.
// For example, "10+10" is an expression as it produces a value (20), but "a <- 10" is
// not.
type Expression interface {
	Node
	expressionNode()
}

// Program is a calclang program, which consists of an initialisation section and a loop
// section.
type Program struct {
	Init *Section
	Loop *Section
}

func (p *Program) Token() token.Token {
	if len(p.Init.Statements) > 0 {
		return p.Init.Statements[0].Token()
	}

	return token.NewToken(token.ILLEGAL, "", 0, 0, 0)
}

func (p *Program) String() string {
	var out bytes.Buffer

	out.WriteString(p.Init.String())

	if p.Loop.String() != "" {
		out.WriteString("\n:::\n")
		out.WriteString(p.Loop.String())
	}

	return out.String()
}

// Section represents a program, which is a collection of statements one after another.
type Section struct {
	Statements []Statement
}

func (p *Section) Token() token.Token {
	if len(p.Statements) > 0 {
		return p.Statements[0].Token()
	}

	return token.NewToken(token.ILLEGAL, "", 0, 0, 0)
}

func (p *Section) String() string {
	var out bytes.Buffer

	for _, stmt := range p.Statements {
		out.WriteString(stmt.String())
	}

	return out.String()
}
